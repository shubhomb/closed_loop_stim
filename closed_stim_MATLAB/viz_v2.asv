%% Read in results from 1/13 mouse session

% Baseline  (20 min) threshold calculation session
% note alpha was 0.18 (~5s memory) for EMA filter, and 5s cooldown after each
% stimulation. 
clear all; 
close all;
% warmup = load('data/1-13-2026/warmup_Xts.mat').warmup_Xts;
% Load the CSV data into the variable warmup_Xts
warmup = readmatrix('data/1-13-2026/warmup_Xts.csv');

% Verify the dimensions match your original data
[rows, cols] = size(warmup);
fprintf('Loaded warmup_Xts: %d timepoints, %d channels\n', rows, cols);

jsonName = "data/1-13-2026/percentiles_2026-01-13.json";
jsonStruct = jsondecode(fileread(jsonName));

% Electrodes
electrodeIDs = {jsonStruct.electrodeID}; 
disp (electrodeIDs)
lowThresholds = [jsonStruct.fifthPercentile]; 
highThresholds = [jsonStruct.ninetyFifthPercentile];

% First stimulation session
stimulation_1 = load('data/1-13-2026/stimulation_Xts_1.mat').stimulation_Xts;
tc1 = load('data/1-13-2026/threshold_crossings_1.mat').threshold_crossings;

% Second stimulation session
tc2 = load('data/1-13-2026/threshold_crossings_2.mat').threshold_crossings;
stimulation_2 = load('data/1-13-2026/stimulation_Xts_2.mat').stimulation_Xts;
recordedChannels = electrodeIDs;

stimSession = 2;
fprintf("Stim session %d \n", stimSession); 
if stimSession == 1
    tc = tc1; 
    stimulation_readout = stimulation_1;
    % Specify and run EMA filter over each channel
elseif stimSession == 2
    tc = tc2;
    stimulation_readout = stimulation_2;
else
    disp ("Using warmup for stimulation statistics in DEBUG mode!");
    stimulation_readout = stimulation_1; 
end






% see moving average calculation used for experiment
emaFiltered = zeros(size(stimulation_readout)); % Initialize matrix for EMA filtered data
alpha = 0.18; % Smoothing factor for EMA

chIdx = 1;
for ch = recordedChannels
    emaFiltered(:, chIdx) = filter(alpha, [1, alpha - 1], stimulation_readout(:, chIdx));
    chIdx = chIdx + 1; 
end

%% Figure 0: Main histogram
period = 0; % Options: 1 (Session 1), 2 (Session 2), 0 (Both Combined)
preWindowIter = 0; 
postWindowIter = 5; 
xSupport = 0:30; 

% Pure Color & Alpha Definitions
pureRed = [1.0, 0.0, 0.0]; pureBlue = [0.0, 0.0, 0.5]; 
alphaLineStim = 0.8; alphaLineNoStim = 0.4;

% Load Session 1
s1 = load('data/1-13-2026/stimulation_Xts_1.mat').stimulation_Xts;
tc1 = load('data/1-13-2026/threshold_crossings_1.mat').threshold_crossings;
% Load Session 2
s2 = load('data/1-13-2026/stimulation_Xts_2.mat').stimulation_Xts;
tc2 = load('data/1-13-2026/threshold_crossings_2.mat').threshold_crossings;

if period == 1
    stimulation_readout = stimulation_1;
    tc_main = tc1;
    periodLabel = "Session 1";
elseif period == 2
    stimulation_readout = stimulation_2;
    tc_main = tc2;
    periodLabel = "Session 2";
elseif period == 0
    % Combine stimulation matrices
    stimulation_readout = [s1; s2];
    tc_main = tc1; % Start with Session 1
    
    % Shift iteration indices of session 2 and merge
    offset = size(s1, 1);
    for i = 1:length(tc2)
        if ~isempty(tc2{i})
            shifted_events = tc2{i};
            for ev = 1:length(shifted_events)
                shifted_events(ev).iter = shifted_events(ev).iter + offset;
            end
            % Append shifted session 2 events to session 1
            if isempty(tc_main{i})
                tc_main{i} = shifted_events;
            else
                tc_main{i} = [tc_main{i}, shifted_events];
            end
        end
    end
    periodLabel = "Sessions 1 & 2 Combined";
end

fprintf("Processing: %s\n", periodLabel);

chIdx = 1;
for ch = recordedChannels
    ch_num = ch{1};
    
    % Ensure the index exists and is not empty
    if ch_num <= length(tc_main) && ~isempty(tc_main{ch_num})
        events = tc_main{ch_num};
        iterIndices = [events.iter];      
        crossingTypes = [events.crossingType];   
        anyStimulated = [events.anyStimThisIter];
        thisStimulated = [events.channelStimulated];
        
        figure('Name', sprintf('Spike Dist - Ch %d', ch_num), 'Color', 'w');
        hold on;
        
        configs = {
            {pureRed,  alphaLineNoStim, 'Low, No Stim'}, ...
            {pureRed,  alphaLineStim,   'Low, Stim'},    ...
            {pureBlue, alphaLineNoStim, 'High, No Stim'}, ...
            {pureBlue, alphaLineStim,   'High, Stim'}
        };
        subplotMasks = {
            (crossingTypes == -1 & ~anyStimulated),
            (crossingTypes == -1 & thisStimulated),
            (crossingTypes == 1 & ~anyStimulated),
            (crossingTypes == 1 & thisStimulated)
        };
        
        for sp = 1:4
            mask = subplotMasks{sp};
            eventIters = iterIndices(mask);
            if isempty(eventIters), continue; end
        
            % 1. Aggregate Spike Values
            spikeValues = [];
            for k = 1:length(eventIters)
                iterCross = eventIters(k);
                idxStart = max(1, iterCross - preWindowIter);
                idxEnd   = min(size(stimulation_readout,1), iterCross + postWindowIter);
                spikeValues = [spikeValues; stimulation_readout(idxStart:idxEnd, chIdx)];
            end
        
            % --- Left Axis: Raw Frequency ---
            yyaxis left
            colorRGB = configs{sp}{1};
            lineAlpha = configs{sp}{2};
            histogram(spikeValues, 'BinEdges', -0.5:1:30.5, ...
                'FaceColor', colorRGB, 'FaceAlpha', lineAlpha/2, ...
                'EdgeColor', 'none', 'DisplayName', configs{sp}{3});
            ylabel('Spike Count Frequency (Raw)');
            set(gca, 'YColor', [0.3 0.3 0.3]); 

            % --- Right Axis: Continuous Density ---
            yyaxis right
            [counts, edges] = histcounts(spikeValues, 'BinEdges', -0.5:1:30.5, 'Normalization', 'pdf');
            binMidpoints = edges(1:end-1) + diff(edges)/2;
            fullDensity = zeros(size(xSupport));
            [~, idxInSupport] = intersect(xSupport, binMidpoints);
            fullDensity(idxInSupport) = counts;
            
            smoothedF = movmean(fullDensity, 3);
            plot(xSupport, smoothedF, 'Color', [colorRGB, lineAlpha], ...
                'LineWidth', 3.5, 'HandleVisibility', 'off');
            ylabel('Probability Density');
            set(gca, 'YColor', [0.1 0.1 0.1]); 
        end

        % Title and Formatting
        xlabel('Spike Count Value');
        title({sprintf('Ch %d Spike Distribution (%s)', ch_num, periodLabel), ...
               sprintf('Window: -%d to +%d Iters', preWindowIter, postWindowIter)});
        
        legend('show', 'Location', 'northeast');
        grid on; xlim([0, 30]); hold off;
        
        saveas(gcf, sprintf('Channel_%d_Period%d_Analysis.png', ch_num, period));
    end
    chIdx = chIdx + 1; % Increment channel index for data lookup
end
%% Figure 0 (VIOLINS): Same masking logic, 4 violins (no histogram/KDE), single copy-paste block
% Toolbox-free (no violinplot, no ksdensity). Uses histcounts + conv + patch.

period = 0; % Options: 1 (Session 1), 2 (Session 2), 0 (Both Combined)
preWindowIter  = 0;
postWindowIter = 5;

% Pure Color & Alpha Definitions
pureRed  = [1.0, 0.0, 0.0];
pureBlue = [0.0, 0.0, 0.5];
alphaLineStim   = 0.8;
alphaLineNoStim = 0.4;

% Load Session 1
s1  = load('data/1-13-2026/stimulation_Xts_1.mat').stimulation_Xts;
tc1 = load('data/1-13-2026/threshold_crossings_1.mat').threshold_crossings;
% Load Session 2
s2  = load('data/1-13-2026/stimulation_Xts_2.mat').stimulation_Xts;
tc2 = load('data/1-13-2026/threshold_crossings_2.mat').threshold_crossings;

% Choose/merge period
if period == 1
    stimulation_readout = s1;
    tc_main = tc1;
    periodLabel = "Session 1";
elseif period == 2
    stimulation_readout = s2;
    tc_main = tc2;
    periodLabel = "Session 2";
else
    stimulation_readout = [s1; s2];
    tc_main = tc1; % start with Session 1

    % Shift iteration indices of session 2 and merge into session 1
    offset = size(s1, 1);
    for i = 1:length(tc2)
        if ~isempty(tc2{i})
            shifted_events = tc2{i};
            for ev = 1:length(shifted_events)
                shifted_events(ev).iter = shifted_events(ev).iter + offset;
            end
            if isempty(tc_main{i})
                tc_main{i} = shifted_events;
            else
                tc_main{i} = [tc_main{i}, shifted_events];
            end
        end
    end
    periodLabel = "Sessions 1 & 2 Combined";
end

fprintf("Processing: %s\n", periodLabel);

% Same ordering as your original masks
configs = {
    {pureRed,  alphaLineNoStim, 'Low, No Stim'}, ...
    {pureRed,  alphaLineStim,   'Low, Stim'},    ...
    {pureBlue, alphaLineNoStim, 'High, No Stim'}, ...
    {pureBlue, alphaLineStim,   'High, Stim'}
};

% --- Violin settings (toolbox-free) ---
xPos = 1:4;                      % 4 separate vertical lines / violins
binEdges   = -0.5:1:30.5;         % integer spike counts 0..30
binCenters = 0:30;
maxHalfWidth    = 0.35;           % max half width of violin
smoothSigmaBins = 0.5;            % smoothing in "bins"
nKernelRadius   = 1;              % +/- bins for Gaussian kernel

xLowCenter  = 1.0;
xHighCenter = 2.2;     % gap between low and high
intraGap    = 0.5;    % spacing within each group

xPos = [ ...
    xLowCenter  - intraGap/2, ...   % Low, No Stim
    xLowCenter  + intraGap/2, ...   % Low, Stim
    xHighCenter - intraGap/2, ...   % High, No Stim
    xHighCenter + intraGap/2  ...   % High, Stim
];
% Precompute Gaussian smoothing kernel (no toolboxes)
kk = (-nKernelRadius:nKernelRadius);
g = exp(-(kk.^2) / (2*smoothSigmaBins^2));
g = g / sum(g);

chIdx = 1;
for ch = recordedChannels
    ch_num = ch{1};

    if ch_num <= length(tc_main) && ~isempty(tc_main{ch_num})
        events = tc_main{ch_num};
        iterIndices    = [events.iter];
        crossingTypes  = [events.crossingType];
        anyStimulated  = [events.anyStimThisIter];
        thisStimulated = [events.channelStimulated];

        figure('Name', sprintf('Spike Dist (Violin) - Ch %d', ch_num), 'Color', 'w');
        hold on;

        % EXACT same masking logic
        subplotMasks = {
            (crossingTypes == -1 & ~anyStimulated), ...
            (crossingTypes == -1 & thisStimulated), ...
            (crossingTypes ==  1 & ~anyStimulated), ...
            (crossingTypes ==  1 & thisStimulated)
        };

        % Collect spikeValues per mask
        spikeValuesByMask = cell(1,4);
        for sp = 1:4
            mask = subplotMasks{sp};
            eventIters = iterIndices(mask);

            if isempty(eventIters)
                spikeValuesByMask{sp} = [];
                continue;
            end

            spikeValues = [];
            for k = 1:length(eventIters)
                iterCross = eventIters(k);
                idxStart = max(1, iterCross - preWindowIter);
                idxEnd   = min(size(stimulation_readout,1), iterCross + postWindowIter);
                spikeValues = [spikeValues; stimulation_readout(idxStart:idxEnd, chIdx)];
            end
            spikeValuesByMask{sp} = spikeValues(:);
        end

        % If no data at all, label and skip
        if all(cellfun(@isempty, spikeValuesByMask))
            title(sprintf('Ch %d: no events for any mask (%s)', ch_num, periodLabel));
            hold off;
            chIdx = chIdx + 1;
            continue;
        end

        % Draw 4 violins (one per mask)
        for sp = 1:4
            v = spikeValuesByMask{sp};
            y = binCenters;

            % Always draw center vertical line (requested)
            plot([xPos(sp) xPos(sp)], [y(1) y(end)], '-', ...
                'Color', [0.2 0.2 0.2 0.35], 'LineWidth', 1.25, 'HandleVisibility', 'off');

            if isempty(v)
                continue;
            end

            % Histogram-based "density"
            counts = histcounts(v, binEdges, 'Normalization', 'pdf');  % length 31
            dens = conv(counts, g, 'same');

            % Scale to half-width
            if max(dens) > 0
                w = (dens / max(dens)) * maxHalfWidth;
            else
                w = zeros(size(dens));
            end

            % Violin polygon around xPos(sp)
            xLeft  = xPos(sp) - w;
            xRight = xPos(sp) + w;

            X = [xLeft, fliplr(xRight)];
            Y = [y,     fliplr(y)];

            colorRGB  = configs{sp}{1};
            lineAlpha = configs{sp}{2};

            patch(X, Y, colorRGB, ...
                'FaceAlpha', min(1, max(0, 0.35 * lineAlpha)), ...
                'EdgeColor', colorRGB, ...
                'EdgeAlpha', min(1, max(0, lineAlpha)), ...
                'LineWidth', 1.5, ...
                'DisplayName', configs{sp}{3});

            % Mean bar (one horizontal line per mask)
            mu = mean(v);
            plot([xPos(sp)-0.14, xPos(sp)+0.14], [mu, mu], '-', ...
                'Color', [0 0 0 0.65], 'LineWidth', 2.5, 'HandleVisibility', 'off');       
        end

        % --- Compute and annotate p-values (No-Stim vs Stim) for Low and High ---
        [pLow, pHigh] = ttest_noStim_vs_stim(spikeValuesByMask);
        
        % Place text above each STATE, centered between its two violins:
        xLowText  = mean(xPos(1:2));   % halfway through intraGap for low
        xHighText = mean(xPos(3:4));   % halfway through intraGap for high
        
        % Put text above the plot
        yText = 29.0;  % adjust if needed (since ylim is [0 30])
        
        text(xLowText,  yText, p_to_label(pLow),  ...
            'HorizontalAlignment', 'center', 'VerticalAlignment', 'bottom', ...
            'FontWeight', 'bold', 'FontSize', 11);
        
        text(xHighText, yText, p_to_label(pHigh), ...
            'HorizontalAlignment', 'center', 'VerticalAlignment', 'bottom', ...
            'FontWeight', 'bold', 'FontSize', 11);


        % Axes formatting
        xlim([0.5 3.3]);
        xticks([xLowCenter, xHighCenter]);
        xticklabels({'Low State', 'High State'});        
        xtickangle(25);

        ylabel('Spike Count Value');
        title({sprintf('Ch %d Spike Distribution (Violin) (%s)', ch_num, periodLabel), ...
               sprintf('Window: -%d to +%d Iters', preWindowIter, postWindowIter)});
        grid on;
        legend('show', 'Location', 'northeast');

        hold off;

        saveas(gcf, sprintf('Channel_%d_Period%d_Violin.png', ch_num, period));
    end

    chIdx = chIdx + 1;
end

%% Figure 1: Channel-level crossing & stimulation summary (dot plot of channel thrxs vs. stimulations, should be positively correlated)

clearvars -except tc electrodeIDs warmup lowThresholds highThresholds stimulation_readout recordedChannels
close all;

numChannels = length(electrodeIDs);

% Preallocate
numCrossings    = zeros(numChannels,1);
numStimulations = zeros(numChannels,1);
numLowCrossings = zeros(numChannels,1);
numHighCrossings= zeros(numChannels,1);

for chIdx = 1:numChannels
    ch_num = electrodeIDs{chIdx};

    if isempty(tc{ch_num})
        continue
    end

    events = tc{ch_num};

    % Total crossings
    numCrossings(chIdx) = length(events);

    % Crossing types
    crossingTypes = [events.crossingType];
    numLowCrossings(chIdx)  = sum(crossingTypes == -1);
    numHighCrossings(chIdx) = sum(crossingTypes == 1);

    % Stimulations
    stimulated = [events.channelStimulated];
    numStimulations(chIdx) = sum(stimulated);
end

% Print summary table
summaryTable = table( ...
    electrodeIDs(:), ...
    numCrossings, ...
    numStimulations, ...
    numLowCrossings, ...
    numHighCrossings, ...
    'VariableNames', {'Channel','TotalCrossings','Stimulations','LowCrossings','HighCrossings'});

disp(summaryTable)

%  Scatter plot: stimulations vs crossings (one dot per channel)
figure('Name','Stimulations vs Channel Crossings','Color','w');
scatter(numCrossings, numStimulations, 80, 'filled');
grid on;

xlabel('Number of Threshold Crossings');
ylabel('Number of Stimulations');
title('Stimulations vs Crossings (One Dot per Channel)');

% Label each point with channel ID
hold on;
for chIdx = 1:numChannels
    if numCrossings(chIdx) > 0
        text(numCrossings(chIdx)+0.2, ...
             numStimulations(chIdx), ...
             sprintf('%d', electrodeIDs{chIdx}), ...
             'FontSize', 9);
    end
end
saveas(gcf, 'Stimulations_vs_Crossings_AllChannels.png');
writetable(summaryTable, 'Channel_Crossing_Stim_Summary.csv');

hold off;

%% Figure 2: Full channel data plot separated by channel (raw data vs. EMA separated for each channel, with threshold crossings shown as windows)
% Channel iteration loop
chIdx = 1;
for ch = recordedChannels
    ch_num = ch{1};
    
    if ~isempty(tc{ch_num})
        events = tc{ch_num};
        eventIters = [events.iter];  % Get the iteration indices for crossings
        stimulated    = [events.channelStimulated]; 
        crossingTypes = [events.crossingType];
        stimulatedIterations = eventIters(stimulated);  % Select the stimulated iterations from eventIters
        % Find length of stimulated iterations
        numStimulatedIterations = length(stimulatedIterations);
        disp(['Number of Stimulated Iterations for Channel ', num2str(ch_num), ': ', num2str(numStimulatedIterations)]);
        % Plot the entire stimulation_readout for the current channel
        figure('Name', sprintf('Readout for Channel %d', ch_num));
        hold on;
        plot(stimulation_readout(:, chIdx), 'Color', [0.6, 0.6, 0.6], 'LineWidth', 1.5); % Plot the entire stimulation readout
        plot(emaFiltered(:, chIdx), 'b', 'LineWidth', 2); % Plot the entire stimulation readout

        ylim([0 40]); % Adjust the limits as needed
        % Plot high and low thresholds as dashed red lines
        yLimits = ylim; % Get current y-limits for proper scaling
        hold on;
        plot(xlim, [lowThresholds(chIdx), lowThresholds(chIdx)], 'r--', 'LineWidth', 1.5); % Low threshold line
        plot(xlim, [highThresholds(chIdx), highThresholds(chIdx)], 'r--', 'LineWidth', 1.5); % High threshold line
        hold on;
       
        for k = 1:length(events)
            if events(k).channelStimulated
                stimTime = events(k).iter;
                if crossingTypes(k) == 1
                    yShade = [highThresholds(chIdx) 40 40 highThresholds(chIdx)];
                    color = 'b';
                else
                    yShade = [0 lowThresholds(chIdx) lowThresholds(chIdx) 0];
                    color = 'y'; 
                end
                xShade = [stimTime stimTime stimTime+5 stimTime+5];
                fill(xShade, yShade, color, 'FaceAlpha',0.3,'EdgeColor','none');
            end
        end
        
        xlabel('Time (s)');
        ylabel('Spike Count (spikes/s)');
        title(sprintf('Stimulation Readout with Windows for Channel %d', ch_num));
        grid on;
        hold off;
        saveas(gcf, sprintf('Stimulation_Readout_Channel_%d.png', ch_num));
    end
    chIdx = chIdx + 1;
end

%% Figure 2b: Full channel data plot separated by channel (raw data vs. EMA separated for each channel, with threshold crossings shown as windows)
% Channel iteration loop
chIdx = 1;
for ch = recordedChannels
end
%% Figure 3: Stacked full channel data plot (shared axes); same as Figure 2 but overlaying all channels

numCh = length(recordedChannels);

figure('Name','Stacked Stimulation Readouts','Color','w');
tiledlayout(numCh, 1, ...
    'TileSpacing','compact', ...
    'Padding','compact');

chIdx = 1;
for ch = recordedChannels
    ch_num = ch{1};
    events = tc{ch_num};  % Retrieve events for the current channel
    crossingTypes = [events.crossingType];   
    nexttile;
    hold on;

    % Plot signals
    plot(stimulation_readout(:, chIdx), 'Color', [0.6, 0.6, 0.6], 'LineWidth', 1);
    plot(emaFiltered(:, chIdx), 'b--', 'LineWidth', 1);

    % Lock axes BEFORE shading
    ylim([0 40]);
    xlim([1 size(stimulation_readout,1)]);

    % Thresholds
    yline(lowThresholds(chIdx),  'r--', 'LineWidth', 1);
    yline(highThresholds(chIdx), 'r--', 'LineWidth', 1);
    events = tc{ch_num};
    for k = 1:length(events)
        if events(k).channelStimulated
            stimTime = events(k).iter;
            if crossingTypes(k) == 1
                yShade = [highThresholds(chIdx) 40 40 highThresholds(chIdx)];
                color = 'b';
            else
                yShade = [0 lowThresholds(chIdx) lowThresholds(chIdx) 0];
                color = 'y'; 
            end
            xShade = [stimTime stimTime stimTime+5 stimTime+5];
            fill(xShade, yShade, color, 'FaceAlpha',0.3,'EdgeColor','none');
        end
        end

    % Channel label (top-right)
    text(0.98, 0.90, sprintf('Ch %d', ch_num), ...
        'Units','normalized', ...
        'HorizontalAlignment','right', ...
        'FontWeight','bold');

    % Clean look
    grid on;
    set(gca,'Box','off');

    % Only bottom plot gets x-label
    if chIdx == numCh
        xlabel('Time (s)');
    else
        set(gca,'XTickLabel',[]);
    end

    % Only middle plot gets y-label (optional)
    if chIdx == ceil(numCh/2)
        ylabel('Spike Count (spikes/s)');
    end

    hold off;
    chIdx = chIdx + 1;
end

% Save figure
saveas(gcf,'Stacked_Stimulation_Readouts_AllChannels.png');

%% Figure 4: Time-series aggregation (traces pre/post stimulation time)
preWindowIter = 2;  % Define the number of iterations before the event
postWindowIter = 2; % Define the number of iterations after the event
chIdx = 1; 
for ch = recordedChannels
    ch_num = ch{1};
      
    if ~isempty(tc{ch_num})
        events = tc{ch_num};
        iterIndices = [events.iter];      
        
        % Print the indices of channel crossings
        numCrossings = length(iterIndices);
        crossingTypes = [events.crossingType];   
        lowCount = sum(crossingTypes == -1);
        highCount = sum(crossingTypes == 1);
        anyStimulated    = [events.anyStimThisIter];
        thisStimulated = [events.channelStimulated];


        % Plot number of stimulations as a function of number of crossings
        % figure('Name', sprintf('Stimulations vs Crossings for Channel %d', ch_num));
        % bar([numCrossings, numStimulations]);
        % set(gca, 'XTickLabel', {'Number of Crossings', 'Number of Stimulations'});
        % ylabel('Count');
        % title(sprintf('Channel %d: Stimulations vs Crossings', ch_num));
        % grid on;

        figure('Name', sprintf('Channel %d', ch_num));

        % Define subplot types
        subplotMasks = {
            (crossingTypes == -1 & ~anyStimulated),  % Low threshold, no stim on any channel
            (crossingTypes == -1 & thisStimulated),                            % Low threshold, stim
            (crossingTypes == 1 & ~anyStimulated),  % High threshold, no stim on any channel
            (crossingTypes == 1 & thisStimulated)                             % High threshold, stim
        };
        subplotTitles = {
            'Low Threshold, No Stim', ...
            'Low Threshold, Stim', ...
            'High Threshold, No Stim', ...
            'High Threshold, Stim'
        };
        thresholds = [lowThresholds(chIdx), lowThresholds(chIdx), highThresholds(chIdx), highThresholds(chIdx)];

        t_common = -preWindowIter:postWindowIter;

        for sp = 1:4
            mask = subplotMasks{sp};
            eventIters = iterIndices(mask);
            if isempty(eventIters)
                continue
            end
        
            subplot(2,2,sp);
            hold on;
        
            allTraces = nan(length(eventIters), length(t_common));
    
            for k = 1:length(eventIters)
                iterCross = eventIters(k);
        
                % Compute actual bounds in data
                idxStart = max(1, iterCross - preWindowIter);
                idxEnd   = min(size(stimulation_readout,1), iterCross + postWindowIter);
        
                Xtrace = stimulation_readout(idxStart:idxEnd, chIdx);
        
                % Where this trace lands in t_common
                tStartIdx = (idxStart - iterCross) + preWindowIter + 1;
                tEndIdx   = tStartIdx + length(Xtrace) - 1;
        
                % Fill into full-length vector
                Xfull = nan(1, length(t_common));
                Xfull(tStartIdx:tEndIdx) = Xtrace;
        
                allTraces(k,:) = Xfull;
        
                % Plot individual trace (continuous)
                plot(t_common, Xfull, 'Color', [0.6 0.6 0.6], 'LineWidth', 1);
            end
        
            % Plot mean trace
            meanTrace = mean(allTraces, 1, 'omitnan');
            plot(t_common, meanTrace, 'k', 'LineWidth', 2);
        
            % Threshold + alignment lines
            yline(thresholds(sp), 'r--', 'LineWidth', 1.5);
            xline(0, 'r--', 'LineWidth', 2);
        
            xlabel('Iterations relative to crossing');
            ylabel('X_t');
            title(sprintf('%s (Ch %d)', subplotTitles{sp}, ch_num));
            grid on;

            % Set common y-limits
            ylim([0, 30]);
            hold off;
        end
        % Save the figure
        saveas(gcf, sprintf('Channel_%d_Stimulation_Analysis.png', ch_num));
        chIdx = chIdx + 1; 
    end
end


%% Figure 5: Number of threshold crossing-channels per iteration histogram (see how many iterations have 0, 1, or more crossings). 

% clearvars -except tc stimulation_readout electrodeIDs
% close all;

numIters    = size(stimulation_readout, 1);
numChannels = length(electrodeIDs);

% Preallocate count vector
crossingsPerIter = zeros(numIters, 1);

% Loop over channels
for chIdx = 1:numChannels
    ch_num = electrodeIDs{chIdx};

    if isempty(tc{ch_num})
        continue
    end

    events = tc{ch_num};
    iterIndices = [events.iter];

    % Accumulate counts
    for k = 1:length(iterIndices)
        iter = iterIndices(k);
        if iter >= 1 && iter <= numIters
            crossingsPerIter(iter) = crossingsPerIter(iter) + 1;
        end
    end
end



maxCrossings = max(crossingsPerIter);

% Define integer bins: 0,1,2,...
binEdges = -0.5 : 1 : (maxCrossings + 0.5);

figure('Name','Histogram of Threshold Crossings per Iteration','Color','w');

histogram(crossingsPerIter, binEdges, ...
    'Normalization','count', ...
    'FaceColor',[0.4 0.4 0.4], ...
    'EdgeColor','k');

grid on;
xlabel('Number of Threshold Crossings in an Iteration');
ylabel('Number of Iterations');
title('Distribution of Threshold Crossings per Iteration');

xticks(0:maxCrossings);

saveas(gcf, 'Histogram_Crossings_Per_Iteration.png');
fprintf('Total iterations: %d\n', numIters);
fprintf('Iterations with zero crossings: %d (%.2f%%)\n', ...
    sum(crossingsPerIter == 0), ...
    100 * mean(crossingsPerIter == 0));

fprintf('Max crossings in a single iteration: %d\n', maxCrossings);

%% Figure 6: Time line per channel of threshold crossing vs. stimulation (sanity check plot)

% clearvars -except tc electrodeIDs warmup lowThresholds highThresholds stimulation_readout recordedChannels
% close all;

numChannels = length(electrodeIDs);
numIters = size(stimulation_readout,1);

figure('Name','Sanity Check: Stim vs Threshold Crossings','Color','w');
hold on;

violations = [];

for chIdx = 1:numChannels
    ch_num = electrodeIDs{chIdx};

    if isempty(tc{ch_num})
        continue
    end

    events = tc{ch_num};

    iters        = [events.iter];             
    stimulated   = [events.channelStimulated]; 
    crossingType = [events.crossingType];

    % Plot all threshold crossings (gray)
    scatter(iters, chIdx*ones(size(iters)), 25, [0.6 0.6 0.6], 'filled');

    % Plot stimulations (red circles)
    stimIters = iters(stimulated);
    scatter(stimIters, chIdx*ones(size(stimIters)), 80, 'r', 'o', 'LineWidth', 1.5);

    % Logical sanity check: stim must occur at a threshold crossing
    for k = find(stimulated)
        if (crossingType(k) ~= -1 && crossingType(k) ~= 1)
            violations(end+1,:) = [iters(k), chIdx];
        end
    end
end

xlabel('Iteration');
ylabel('Channel Index');
yticks(1:numChannels);
yticklabels(electrodeIDs);
title('Sanity Check: Threshold Crossings (gray) vs Stimulations (red)');

% Count the number of violations
numViolations = size(violations, 1);
fprintf('Number of threshold-crossing violations: %d\n', numViolations);
grid on;

% Legend
scatter(nan,nan,25,[0.6 0.6 0.6],'filled');
scatter(nan,nan,80,'r','o','LineWidth',1.5);
legend({'Threshold Crossing','Stimulation Delivered'},'Location','best');

hold off;

saveas(gcf,'SanityCheck_Stim_vs_Threshold_1216Session.png');

% Optional hard assertion
if ~isempty(violations)
    warning('Stim delivered without threshold crossing! First violation: Iter=%d, Ch=%s', ...
            violations(1,1), electrodeIDs{violations(1,2)});
else
    disp('âœ“ Sanity check passed: all stimulations coincide with threshold crossings');
end


%% Figure 7: Compare warmup and stimulation periods time series across channels

figure('Name','Overlay Warmup and Stimulation Plots','Color','w');

warmupColor = [0.2 0.6 0.2];
stimColor   = [0.6 0.2 0.2];

numChannels = length(electrodeIDs);
startPoint  = 5;

for chIdx = 1:numChannels
    ch_num = electrodeIDs{chIdx};  % label only

    subplot(numChannels, 1, chIdx);
    hold on;

    % ---- Warmup ----
    yWarm = warmup(startPoint:end, chIdx);
    xWarm = startPoint : startPoint + numel(yWarm) - 1;
    plot(xWarm, yWarm, 'Color', warmupColor, 'LineWidth', 1.5);

    % ---- Stimulation ----
    yStim = stimulation_readout(startPoint:end, chIdx);
    xStim = startPoint : startPoint + numel(yStim) - 1;
    plot(xStim, yStim, 'Color', stimColor, 'LineWidth', 1.5);

    ylabel(sprintf('Ch %d', ch_num));
    grid on;
    box off;

    if chIdx == numChannels
        xlabel('Iteration');
    else
        set(gca, 'XTickLabel', []);
    end
end

sgtitle('Overlay of Warmup and Stimulation Threshold Crossings');
saveas(gcf, 'Overlay_Warmup_Stimulation_Plots.png');


%% Figure 8: Fraction of crossings per channel that resulted in stimulation bar plot 

numChannels = length(electrodeIDs);

propStimulated = nan(numChannels,1);
numTotalCross  = zeros(numChannels,1);
numStimCoin    = zeros(numChannels,1);

for chIdx = 1:numChannels
    ch_num = electrodeIDs{chIdx};

    if isempty(tc{ch_num})
        continue
    end

    events = tc{ch_num};

    stimulated = [events.channelStimulated];
    numTotalCross(chIdx) = numel(events);

    numStimCoin(chIdx) = sum(stimulated);

    % Proportion
    propStimulated(chIdx) = numStimCoin(chIdx) / numTotalCross(chIdx);

end

hold on;
for chIdx = 1:numChannels
    if numTotalCross(chIdx) > 0
        text(chIdx, propStimulated(chIdx) + 0.03, ...
            sprintf('%d/%d', numStimCoin(chIdx), numTotalCross(chIdx)), ...
            'HorizontalAlignment','center', ...
            'FontSize',9);
    end
end
hold off;


figure('Name','Proportion of Crossings Resulting in Stimulation','Color','w');

bar(propStimulated, 'FaceColor',[0.3 0.3 0.7]);
ylim([0 1]);
yline(0.5, 'r--','LabelHorizontalAlignment','left', 'LabelVerticalAlignment','middle', 'LineWidth', 1.5);

xlabel('Channel');
ylabel('Proportion of Crossings Stimulated');
title('Fraction of Threshold Crossings That Resulted in Stimulation');

xticks(1:numChannels);
xticklabels(electrodeIDs);
xtickangle(45);

grid on;
box off;

saveas(gcf,'Proportion_Stimulated_Per_Channel.png');


%% Figure 9: Overlaid histograms per channel + normalized density (yyaxis). Show whether baseline distribution independent of time matches that of stimulation periods'. 
% -------------------------------
% Disable axes toolbar globally
% -------------------------------
set(groot, 'defaultAxesToolbarVisible', 'off');

% -------------------------------
% Compute GLOBAL robust x-range
% -------------------------------
allValsGlobal = [
    warmup(:);
    stimulation_1(:);
    stimulation_2(:)
];

allValsGlobal = allValsGlobal(~isnan(allValsGlobal));

xLow  = prctile(allValsGlobal, 1);
xHigh = prctile(allValsGlobal, 99.5);

if xLow >= xHigh
    xLow  = min(allValsGlobal);
    xHigh = max(allValsGlobal);
end

nBins = 30;
edges = linspace(xLow, xHigh, nBins + 1);

% -------------------------------
% Plot per channel
% -------------------------------
numChannels = length(recordedChannels);

for chIdx = 1:numChannels
    ch_num = recordedChannels{chIdx};

    % Extract channel data
    warm_vals  = warmup(:, chIdx);
    stim1_vals = stimulation_1(:, chIdx);
    stim2_vals = stimulation_2(:, chIdx);

    % Remove NaNs
    warm_vals  = warm_vals(~isnan(warm_vals));
    stim1_vals = stim1_vals(~isnan(stim1_vals));
    stim2_vals = stim2_vals(~isnan(stim2_vals));

    % Clip to plotting range
    warm_plot  = warm_vals(warm_vals  >= 0 & warm_vals  <= xHigh);
    stim1_plot = stim1_vals(stim1_vals >= 0 & stim1_vals <= xHigh);
    stim2_plot = stim2_vals(stim2_vals >= 0 & stim2_vals <= xHigh);

    if isempty(warm_plot) && isempty(stim1_plot) && isempty(stim2_plot)
        continue
    end

    % -------------------------------
    % Plot
    % -------------------------------
    fig = figure('Name', sprintf('Channel %d', ch_num), ...
                 'Color', 'w', ...
                 'Toolbar', 'none');
    hold on;

    % ---- LEFT AXIS: HISTOGRAMS ----
    yyaxis left

    histogram(warm_plot, ...
        'BinEdges', edges, ...
        'FaceColor', [0.6 0.6 0.6], ...
        'FaceAlpha', 0.7, ...
        'EdgeColor', 'none');

    histogram(stim1_plot, ...
        'BinEdges', edges, ...
        'FaceColor', [0.2 0.6 0.2], ...
        'FaceAlpha', 0.6, ...
        'EdgeColor', 'none');

    histogram(stim2_plot, ...
        'BinEdges', edges, ...
        'FaceColor', [0.2 0.2 0.8], ...
        'FaceAlpha', 0.6, ...
        'EdgeColor', 'none');

    ylabel('Count');
    xlim([xLow xHigh]);
    xticks(floor(xLow):ceil(xHigh));

    % ---- RIGHT AXIS: NORMALIZED DENSITY ----
    yyaxis right
    ylim([0 1]);
    ylabel('Normalized density');

    sigma = 1.0;   % smoothing width (bins)

    % SOLID = no stimulation
    plotSmoothHistLine(warm_plot,  edges, [0.4 0.4 0.4], 0.9, '-',  sigma);
    plotSmoothHistLine(stim1_plot, edges, [0.2 0.6 0.2], 0.9, '--', sigma);
    plotSmoothHistLine(stim2_plot, edges, [0.2 0.2 0.8], 0.9, '--', sigma);

    % -------------------------------
    % Labels & export
    % -------------------------------
    xlabel('X_t value');
    title(sprintf('Channel %d: Warmup vs Stimulation', ch_num));

    legend({'Warmup', 'Stim 1', 'Stim 2', ...
            'Warmup density', 'Stim 1 density', 'Stim 2 density'}, ...
           'Location', 'best');

    grid on;
    box off;

    saveas(gcf,sprintf('overlap_histogram_Channel__%d.png', ch_num));

end




function plotSmoothHistLine(data, edges, color, alpha, lineStyle, sigma)
    if isempty(data)
        return
    end

    % Histogram counts
    counts = histcounts(data, edges);
    centers = edges(1:end-1) + diff(edges)/2;

    % ---- Manual Gaussian kernel (no toolboxes) ----
    halfWidth = 2;      % kernel radius
    x = -halfWidth:halfWidth;
    kernel = exp(-(x.^2)/(2*sigma^2));
    kernel = kernel / sum(kernel);

    smoothCounts = conv(counts, kernel, 'same');

    % ---- Normalize to [0, 1] ----
    if max(smoothCounts) > 0
        smoothCounts = smoothCounts / max(smoothCounts);
    end

    % Plot line
    plot(centers, smoothCounts, ...
        'Color', [color alpha], ...
        'LineWidth', 2, ...
        'LineStyle', lineStyle);
end




%% --- Add these helper functions at the END of your script (or in separate .m files) ---

function [pLow, pHigh, statsOut] = ttest_noStim_vs_stim(spikeValuesByMask)
% 2-sided Welch t-tests (unequal variances) comparing No-Stim vs Stim means
% Inputs:
%   spikeValuesByMask : 1x4 cell
%       {1}=Low, No Stim
%       {2}=Low, Stim
%       {3}=High, No Stim
%       {4}=High, Stim
% Outputs:
%   pLow  : p-value for Low (mask 1 vs 2)
%   pHigh : p-value for High (mask 3 vs 4)
%   statsOut: struct with t-stats/dfs and means

    a = spikeValuesByMask{1}; b = spikeValuesByMask{2};
    c = spikeValuesByMask{3}; d = spikeValuesByMask{4};

    % Default NaNs if insufficient data
    pLow = NaN; pHigh = NaN;

    statsOut = struct();
    statsOut.low = struct('meanNoStim', mean_safe(a), 'meanStim', mean_safe(b), ...
                          'tstat', NaN, 'df', NaN);
    statsOut.high = struct('meanNoStim', mean_safe(c), 'meanStim', mean_safe(d), ...
                           'tstat', NaN, 'df', NaN);

    % Low state test
    if ~isempty(a) && ~isempty(b) && numel(a) >= 2 && numel(b) >= 2
        [~, pLow, ~, sLow] = ttest2(a, b, 'Vartype', 'unequal'); % Welch
        statsOut.low.tstat = sLow.tstat;
        statsOut.low.df    = sLow.df;
    end

    % High state test
    if ~isempty(c) && ~isempty(d) && numel(c) >= 2 && numel(d) >= 2
        [~, pHigh, ~, sHigh] = ttest2(c, d, 'Vartype', 'unequal'); % Welch
        statsOut.high.tstat = sHigh.tstat;
        statsOut.high.df    = sHigh.df;
    end
end

function m = mean_safe(x)
    if isempty(x), m = NaN; else, m = mean(x); end
end

function s = p_to_label(p)
% Pretty p-value text
    if isnan(p)
        s = 'p = NaN';
    elseif p < 1e-4
        s = sprintf('p < 1e-4');
    else
        s = sprintf('p = %.3g', p);
    end
end
